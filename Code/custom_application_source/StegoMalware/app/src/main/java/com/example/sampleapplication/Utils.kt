package com.example.sampleapplication

import android.content.Context
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.content.ContextCompat
import org.opencv.android.OpenCVLoader
import org.opencv.core.Mat
import org.opencv.imgcodecs.Imgcodecs
import java.io.File
import java.io.FileOutputStream

object Utils{

    private fun copyDrawableToInternalStorage(context: Context, drawableId: Int, fileName: String): String? {
        try {
            // Open the drawable resource as InputStream
            val inputStream = context.resources.openRawResource(drawableId)

            // Create a file in the internal storage
            val file = File(context.filesDir, fileName)
            val outputStream = FileOutputStream(file)

            // Copy the InputStream to the FileOutputStream
            inputStream.use { input ->
                outputStream.use { output ->
                    input.copyTo(output)
                }
            }

            // Return the absolute path of the file
            return file.absolutePath
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return null
    }

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    fun loadBitmapFromDrawable(context: Context, drawableId: Int): Bitmap {
        // Get the drawable from the resources
        val drawable = ContextCompat.getDrawable(context, drawableId)
        Log.i("LoadImage", (drawable is BitmapDrawable).toString())
        // Check if the drawable is not null
        if (drawable is BitmapDrawable) {
            // If the drawable is a BitmapDrawable, just return the bitmap
            Log.i("LoadImage", drawable.bitmap.config.toString())
            return drawable.bitmap
            //Log.i("LoadImage", convertedBitmap.config.toString())
            //return convertedBitmap
        }
        // If the drawable is not a BitmapDrawable, we need to create a Bitmap from it
        val bitmap = Bitmap.createBitmap(drawable!!.intrinsicWidth, drawable.intrinsicHeight, Bitmap.Config.RGBA_1010102)

        return bitmap
    }

     fun loadImageBytesFromFile(context: Context, drawableId: Int): Mat {

        val filePath = copyDrawableToInternalStorage(context, drawableId,
            context.resources.getResourceEntryName(drawableId))
        val mat = Imgcodecs.imread(filePath, Imgcodecs.IMREAD_UNCHANGED)

        return mat
    }

    fun bitsToString(binaryMessage: StringBuilder): String {
        Log.i("Stego", binaryMessage.toString())
        val bytes = binaryMessage.chunked(8)
            .map {
                val byteValue = it.toInt(2).toByte()
                if (byteValue < 0) 0.toByte() else byteValue
            }
            .takeWhile { it != 0.toByte() }//.// Stop at the null byte delimiter
            //filter { it.toInt() in 32..127 } // eliminate non ascii
        Log.i("Stego", bytes.toString())
        return bytes.toByteArray().toString(Charsets.UTF_8)
    }

    fun bitsToString1(binaryMessage: StringBuilder): String{
        val bytes = mutableListOf<Byte>()

        var index = 0
        while (index + 8 <= binaryMessage.length) {
            val byteString = binaryMessage.substring(index, index + 8)
            val byteValue = byteString.toInt(2).toByte()
            if (byteValue == 0.toByte()) break // Stop at the null byte delimiter
            bytes.add(byteValue)
            index += 8
        }

        return bytes.toByteArray().toString(Charsets.UTF_8)
    }

    fun appendBit(binaryMessage: StringBuilder, red: Int, green: Int, blue: Int): StringBuilder{

        binaryMessage.append(red and 1)
        binaryMessage.append(green and 1)
        binaryMessage.append(blue and 1)

        return binaryMessage
    }

    fun appendBit(binaryMessage: StringBuilder, red: String, green: String, blue: String): StringBuilder{

        binaryMessage.append(red)
        binaryMessage.append(green)
        binaryMessage.append(blue)

        return binaryMessage
    }

    fun callStaticApiByName(className: String, methodName: String, vararg args: Any) {
        try {
            val clazz = Class.forName(className)

            val method = clazz.methods.find { it.name == methodName }
            if (method != null) {
                method.invoke(null, *args)
            } else {
                println("No such method: $methodName in $className")
            }
        } catch (e: ClassNotFoundException) {
            println("Error: Class not found - $className")
        } catch (e: Exception) {
            println("Error invoking method: ${e.message}")
        }
    }

    fun callDynamicApiByName(obj: Any, functionName: String, typeParam: Class<*>?, param: String?) {
        try {
            val method = obj::class.java.getMethod(functionName, typeParam)

            method.invoke(obj, param)
        } catch (e: NoSuchMethodException) {
            println("Error: Method '$functionName' not found in ${obj::class.java.name}.")
        } catch (e: IllegalAccessException) {
            println("Error: Unable to access method '$functionName' in ${obj::class.java.name}.")
        } catch (e: IllegalArgumentException) {
            println("Error: Invalid arguments for method '$functionName' in ${obj::class.java.name}.")
        } catch (e: Exception) {
            println("Error: An unexpected error occurred: ${e.message}")
        }
    }

}